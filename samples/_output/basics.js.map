{
"version":3,
"file":"basics.js",
"sourceRoot":"file:///",
"sources":["/usr/lib/haxe/std/js/_std/HxOverrides.hx","/usr/lib/haxe/std/js/_std/Reflect.hx","/usr/lib/haxe/std/js/_std/Std.hx","/usr/lib/haxe/std/js/_std/Type.hx","/usr/lib/haxe/std/haxe/Timer.hx","/usr/lib/haxe/std/js/_std/haxe/ds/ObjectMap.hx","/usr/lib/haxe/std/js/Boot.hx","/haxe/pixi-haxe/.haxelib/actuate/1,8,6/motion/actuators/GenericActuator.hx","/haxe/pixi-haxe/.haxelib/actuate/1,8,6/motion/actuators/SimpleActuator.hx","/haxe/pixi-haxe/.haxelib/actuate/1,8,6/motion/easing/Expo.hx","/haxe/pixi-haxe/.haxelib/actuate/1,8,6/motion/Actuate.hx","/haxe/pixi-haxe/.haxelib/actuate/1,8,6/motion/actuators/MethodActuator.hx","/haxe/pixi-haxe/.haxelib/actuate/1,8,6/motion/actuators/MotionPathActuator.hx","/haxe/pixi-haxe/.haxelib/actuate/1,8,6/motion/actuators/PropertyDetails.hx","/haxe/pixi-haxe/samples/basics/Main.hx"],
"sourcesContent":["/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\n\tstatic function dateStr( date :Date ) : String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear()\n\t\t\t+\"-\"+(if( m < 10 ) \"0\"+m else \"\"+m)\n\t\t\t+\"-\"+(if( d < 10 ) \"0\"+d else \"\"+d)\n\t\t\t+\" \"+(if( h < 10 ) \"0\"+h else \"\"+h)\n\t\t\t+\":\"+(if( mi < 10 ) \"0\"+mi else \"\"+mi)\n\t\t\t+\":\"+(if( s < 10 ) \"0\"+s else \"\"+s);\n\t}\n\n\tstatic function strDate( s : String ) : Date {\n\t\tswitch( s.length ) {\n\t\tcase 8: // hh:mm:ss\n\t\t\tvar k = s.split(\":\");\n\t\t\tvar d : Date = untyped __new__(Date);\n\t\t\tuntyped d[\"setTime\"](0);\n\t\t\tuntyped d[\"setUTCHours\"](k[0]);\n\t\t\tuntyped d[\"setUTCMinutes\"](k[1]);\n\t\t\tuntyped d[\"setUTCSeconds\"](k[2]);\n\t\t\treturn d;\n\t\tcase 10: // YYYY-MM-DD\n\t\t\tvar k = s.split(\"-\");\n\t\t\treturn new Date(cast k[0],cast untyped k[1] - 1,cast k[2],0,0,0);\n\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\tvar k = s.split(\" \");\n\t\t\tvar y = k[0].split(\"-\");\n\t\t\tvar t = k[1].split(\":\");\n\t\t\treturn new Date(cast y[0],cast untyped y[1] - 1,cast y[2],cast t[0],cast t[1],cast t[2]);\n\t\tdefault:\n\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\tstatic function cca( s : String, index : Int ) : Null<Int> {\n\t\tvar x = (cast s).charCodeAt(index);\n\t\tif( x != x ) // fast isNaN\n\t\t\treturn untyped undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\tstatic function substr( s : String, pos : Int, ?len : Int ) : String {\n\t\tif( pos != null && pos != 0 && len != null && len < 0 ) return \"\";\n\t\tif( len == null ) len = s.length;\n\t\tif( pos < 0 ){\n\t\t\tpos = s.length + pos;\n\t\t\tif( pos < 0 ) pos = 0;\n\t\t}else if( len < 0 ){\n\t\t\tlen = s.length + len - pos;\n\t\t}\n\n\t\treturn (untyped s).substr(pos, len);\n\t}\n\n\tstatic function indexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0) i = 0;\n\t\t}\n\t\twhile (i < len)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function lastIndexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>( a : Array<T>, obj : T ) {\n\t\tvar i = a.indexOf(obj);\n\t\tif( i == -1 ) return false;\n\t\ta.splice(i,1);\n\t\treturn true;\n\t}\n\n\tstatic function iter<T>( a : Array<T> ) : Iterator<T> untyped {\n\t\treturn {\n\t\t\tcur : 0,\n\t\t\tarr : a,\n\t\t\thasNext : function() {\n\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t}\n\t\t};\n\t}\n\n\tstatic function __init__() untyped {\n#if !js_es5\n\t\t__feature__('HxOverrides.indexOf', if( Array.prototype.indexOf ) __js__(\"HxOverrides\").indexOf = function(a,o,i) return Array.prototype.indexOf.call(a, o, i));\n\t\t__feature__('HxOverrides.lastIndexOf', if( Array.prototype.lastIndexOf ) __js__(\"HxOverrides\").lastIndexOf = function(a,o,i) return Array.prototype.lastIndexOf.call(a, o, i));\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class Reflect {\n\n\tpublic inline static function hasField( o : Dynamic, field : String ) : Bool {\n\t\treturn untyped __js__('Object').prototype.hasOwnProperty.call(o, field);\n\t}\n\n\tpublic static function field( o : Dynamic, field : String ) : Dynamic {\n\t\ttry return untyped o[field] catch( e : Dynamic ) return null;\n\t}\n\n\tpublic inline static function setField( o : Dynamic, field : String, value : Dynamic ) : Void untyped {\n\t\to[field] = value;\n\t}\n\n\tpublic static inline function getProperty( o : Dynamic, field : String ) : Dynamic untyped {\n\t\tvar tmp;\n\t\treturn if( o == null ) __define_feature__(\"Reflect.getProperty\",null) else if( o.__properties__ && (tmp=o.__properties__[\"get_\"+field]) ) o[tmp]() else o[field];\n\t}\n\n\tpublic static inline function setProperty( o : Dynamic, field : String, value : Dynamic ) : Void untyped {\n\t\tvar tmp;\n\t\tif( o.__properties__ && (tmp=o.__properties__[\"set_\"+field]) ) o[tmp](value) else o[field] = __define_feature__(\"Reflect.setProperty\",value);\n\t}\n\n\tpublic inline static function callMethod( o : Dynamic, func : haxe.Constraints.Function, args : Array<Dynamic> ) : Dynamic untyped {\n\t\treturn func.apply(o,args);\n\t}\n\n\tpublic static function fields( o : Dynamic ) : Array<String> {\n\t\tvar a = [];\n\t\tif (o != null) untyped {\n\t\t\tvar hasOwnProperty = __js__('Object').prototype.hasOwnProperty;\n\t\t\t__js__(\"for( var f in o ) {\");\n\t\t\tif( f != \"__id__\" && f != \"hx__closures__\" && hasOwnProperty.call(o, f) ) a.push(f);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static function isFunction( f : Dynamic ) : Bool untyped {\n\t\treturn __js__(\"typeof(f)\") == \"function\" && !(js.Boot.isClass(f) || js.Boot.isEnum(f));\n\t}\n\n\tpublic static function compare<T>( a : T, b : T ) : Int {\n\t\treturn ( a == b ) ? 0 : (((cast a) > (cast b)) ? 1 : -1);\n\t}\n\n\tpublic static function compareMethods( f1 : Dynamic, f2 : Dynamic ) : Bool {\n\t\tif( f1 == f2 )\n\t\t\treturn true;\n\t\tif( !isFunction(f1) || !isFunction(f2) )\n\t\t\treturn false;\n\t\treturn f1.scope == f2.scope && f1.method == f2.method && f1.method != null;\n\t}\n\n\tpublic static function isObject( v : Dynamic ) : Bool untyped {\n\t\tif( v == null )\n\t\t\treturn false;\n\t\tvar t = __js__(\"typeof(v)\");\n\t\treturn (t == \"string\" || (t == \"object\" && v.__enum__ == null)) || (t == \"function\" && (js.Boot.isClass(v) || js.Boot.isEnum(v)) != null);\n\t}\n\n\tpublic static function isEnumValue( v : Dynamic ) : Bool {\n\t\treturn v != null && v.__enum__ != null;\n\t}\n\n\tpublic static function deleteField( o : Dynamic, field : String ) : Bool untyped {\n\t\tif( !hasField(o,field) ) return false;\n\t\t__js__(\"delete\")(o[field]);\n\t\treturn true;\n\t}\n\n\tpublic static function copy<T>( o : T ) : T {\n\t\tvar o2 : Dynamic = {};\n\t\tfor( f in Reflect.fields(o) )\n\t\t\tReflect.setField(o2,f,Reflect.field(o,f));\n\t\treturn o2;\n\t}\n\n\t@:overload(function( f : Array<Dynamic> -> Void ) : Dynamic {})\n\tpublic static function makeVarArgs( f : Array<Dynamic> -> Dynamic ) : Dynamic {\n\t\treturn function() {\n\t\t\tvar a = untyped Array.prototype.slice.call(__js__(\"arguments\"));\n\t\t\treturn f(a);\n\t\t};\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nimport js.Boot;\n\n@:keepInit\n@:coreApi class Std {\n\n\tpublic static inline function is( v : Dynamic, t : Dynamic ) : Bool {\n\t\treturn untyped js.Boot.__instanceof(v,t);\n\t}\n\n\tpublic static inline function instance<T:{},S:T>( value : T, c : Class<S> ) : S {\n\t\treturn untyped __instanceof__(value, c) ? cast value : null;\n\t}\n\n\tpublic static function string( s : Dynamic ) : String {\n\t\treturn untyped js.Boot.__string_rec(s,\"\");\n\t}\n\n\tpublic static inline function int( x : Float ) : Int {\n\t\treturn (cast x) | 0;\n\t}\n\n\tpublic static function parseInt( x : String ) : Null<Int> {\n\t\tvar v = untyped __js__(\"parseInt\")(x, 10);\n\t\t// parse again if hexadecimal\n\t\tif( v == 0 && (x.charCodeAt(1) == 'x'.code || x.charCodeAt(1) == 'X'.code) )\n\t\t\tv = untyped __js__(\"parseInt\")(x);\n\t\tif( untyped __js__(\"isNaN\")(v) )\n\t\t\treturn null;\n\t\treturn cast v;\n\t}\n\n\tpublic static inline function parseFloat( x : String ) : Float {\n\t\treturn untyped __js__(\"parseFloat\")(x);\n\t}\n\n\tpublic static function random( x : Int ) : Int {\n\t\treturn untyped x <= 0 ? 0 : Math.floor(Math.random()*x);\n\t}\n\n\tstatic function __init__() : Void untyped {\n\t\t__feature__(\"js.Boot.getClass\",String.prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"String\"] = String,String));\n\t\t__feature__(\"js.Boot.isClass\",String.__name__ = __feature__(\"Type.getClassName\",[\"String\"],true));\n\t\t__feature__(\"Type.resolveClass\",$hxClasses[\"Array\"] = Array);\n\t\t__feature__(\"js.Boot.isClass\",Array.__name__ = __feature__(\"Type.getClassName\",[\"Array\"],true));\n\t\t__feature__(\"Date.*\", {\n\t\t\t__feature__(\"js.Boot.getClass\",__js__('Date').prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"Date\"] = __js__('Date'),__js__('Date')));\n\t\t\t__feature__(\"js.Boot.isClass\",__js__('Date').__name__ = [\"Date\"]);\n\t\t});\n\t\t__feature__(\"Int.*\",{\n\t\t\tvar Int = __feature__(\"Type.resolveClass\", $hxClasses[\"Int\"] = { __name__ : [\"Int\"] }, { __name__ : [\"Int\"] });\n\t\t});\n\t\t__feature__(\"Dynamic.*\",{\n\t\t\tvar Dynamic = __feature__(\"Type.resolveClass\", $hxClasses[\"Dynamic\"] = { __name__ : [\"Dynamic\"] }, { __name__ : [\"Dynamic\"] });\n\t\t});\n\t\t__feature__(\"Float.*\",{\n\t\t\tvar Float = __feature__(\"Type.resolveClass\", $hxClasses[\"Float\"] = __js__(\"Number\"), __js__(\"Number\"));\n\t\t\tFloat.__name__ = [\"Float\"];\n\t\t});\n\t\t__feature__(\"Bool.*\",{\n\t\t\tvar Bool = __feature__(\"Type.resolveEnum\",$hxClasses[\"Bool\"] = __js__(\"Boolean\"), __js__(\"Boolean\"));\n\t\t\tBool.__ename__ = [\"Bool\"];\n\t\t});\n\t\t__feature__(\"Class.*\",{\n\t\t\tvar Class = __feature__(\"Type.resolveClass\", $hxClasses[\"Class\"] = { __name__ : [\"Class\"] }, { __name__ : [\"Class\"] });\n\t\t});\n\t\t__feature__(\"Enum.*\",{\n\t\t\tvar Enum = {};\n\t\t});\n\t\t__feature__(\"Void.*\",{\n\t\t\tvar Void = __feature__(\"Type.resolveEnum\", $hxClasses[\"Void\"] = { __ename__ : [\"Void\"] }, { __ename__ : [\"Void\"] });\n\t\t});\n\n#if !js_es5\n\t\t__feature__(\"Array.map\",\n\t\t\tif( Array.prototype.map == null )\n\t\t\t\tArray.prototype.map = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length )\n\t\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n\t\t__feature__(\"Array.filter\",\n\t\t\tif( Array.prototype.filter == null )\n\t\t\t\tArray.prototype.filter = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length ) {\n\t\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\t\tif( f(e) ) a.push(e);\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nenum ValueType {\n\tTNull;\n\tTInt;\n\tTFloat;\n\tTBool;\n\tTObject;\n\tTFunction;\n\tTClass( c : Class<Dynamic> );\n\tTEnum( e : Enum<Dynamic> );\n\tTUnknown;\n}\n\n@:coreApi class Type {\n\n\tpublic static inline function getClass<T>( o : T ) : Class<T> {\n\t\treturn if (o == null) null else @:privateAccess js.Boot.getClass(o);\n\t}\n\n\tpublic static function getEnum( o : EnumValue ) : Enum<Dynamic> untyped {\n\t\tif( o == null )\n\t\t\treturn null;\n\t\treturn o.__enum__;\n\t}\n\n\tpublic static function getSuperClass( c : Class<Dynamic> ) : Class<Dynamic> untyped {\n\t\treturn c.__super__;\n\t}\n\n\n\tpublic static function getClassName( c : Class<Dynamic> ) : String {\n\t\tvar a : Array<String> = untyped c.__name__;\n\t\tif (a == null)\n\t\t\treturn null;\n\t\treturn a.join(\".\");\n\t}\n\n\tpublic static function getEnumName( e : Enum<Dynamic> ) : String {\n\t\tvar a : Array<String> = untyped e.__ename__;\n\t\treturn a.join(\".\");\n\t}\n\n\tpublic static function resolveClass( name : String ) : Class<Dynamic> untyped {\n\t\tvar cl : Class<Dynamic> = $hxClasses[name];\n\t\t// ensure that this is a class\n\t\tif( cl == null || !js.Boot.isClass(cl) )\n\t\t\treturn null;\n\t\treturn cl;\n\t}\n\n\tpublic static function resolveEnum( name : String ) : Enum<Dynamic> untyped {\n\t\tvar e : Dynamic = $hxClasses[name];\n\t\t// ensure that this is an enum\n\t\tif( e == null || !js.Boot.isEnum(e) )\n\t\t\treturn null;\n\t\treturn e;\n\t}\n\n\tpublic static function createInstance<T>( cl : Class<T>, args : Array<Dynamic> ) : T untyped {\n\t\tswitch( args.length ) {\n\t\tcase 0:\n\t\t\treturn __new__(cl);\n\t\tcase 1:\n\t\t\treturn __new__(cl,args[0]);\n\t\tcase 2:\n\t\t\treturn __new__(cl,args[0],args[1]);\n\t\tcase 3:\n\t\t\treturn __new__(cl,args[0],args[1],args[2]);\n\t\tcase 4:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3]);\n\t\tcase 5:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4]);\n\t\tcase 6:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5]);\n\t\tcase 7:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6]);\n\t\tcase 8:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]);\n\t\tdefault:\n\t\t\tthrow \"Too many arguments\";\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static function createEmptyInstance<T>( cl : Class<T> ) : T untyped {\n\t\t__js__(\"function empty() {}; empty.prototype = cl.prototype\");\n\t\treturn __js__(\"new empty()\");\n\t}\n\n\tpublic static function createEnum<T>( e : Enum<T>, constr : String, ?params : Array<Dynamic> ) : T {\n\t\tvar f:Dynamic = Reflect.field(e,constr);\n\t\tif( f == null ) throw \"No such constructor \"+constr;\n\t\tif( Reflect.isFunction(f) ) {\n\t\t\tif( params == null ) throw \"Constructor \"+constr+\" need parameters\";\n\t\t\treturn Reflect.callMethod(e,f,params);\n\t\t}\n\t\tif( params != null && params.length != 0 )\n\t\t\tthrow \"Constructor \"+constr+\" does not need parameters\";\n\t\treturn f;\n\t}\n\n\tpublic static function createEnumIndex<T>( e : Enum<T>, index : Int, ?params : Array<Dynamic> ) : T {\n\t\tvar c : String = (untyped e.__constructs__)[index];\n\t\tif( c == null ) throw index+\" is not a valid enum constructor index\";\n\t\treturn createEnum(e,c,params);\n\t}\n\n\tpublic static function getInstanceFields( c : Class<Dynamic> ) : Array<String> {\n\t\tvar a = [];\n\t\tuntyped __js__(\"for(var i in c.prototype) a.push(i)\");\n\t\ta.remove(\"__class__\");\n\t\ta.remove(\"__properties__\");\n\t\treturn a;\n\t}\n\n\tpublic static function getClassFields( c : Class<Dynamic> ) : Array<String> {\n\t\tvar a = Reflect.fields(c);\n\t\ta.remove(\"__name__\");\n\t\ta.remove(\"__interfaces__\");\n\t\ta.remove(\"__properties__\");\n\t\ta.remove(\"__super__\");\n\t\ta.remove(\"__meta__\");\n\t\ta.remove(\"prototype\");\n\t\treturn a;\n\t}\n\n\tpublic static function getEnumConstructs( e : Enum<Dynamic> ) : Array<String> {\n\t\tvar a : Array<String> = untyped e.__constructs__;\n\t\treturn a.copy();\n\t}\n\n\tpublic static function typeof( v : Dynamic ) : ValueType untyped {\n\t\tswitch( __js__(\"typeof\")(v) ) {\n\t\tcase \"boolean\": return TBool;\n\t\tcase \"string\": return TClass(String);\n\t\tcase \"number\":\n\t\t\t// this should handle all cases : NaN, +/-Inf and Floats outside range\n\t\t\tif( Math.ceil(v) == v%2147483648.0 )\n\t\t\t\treturn TInt;\n\t\t\treturn TFloat;\n\t\tcase \"object\":\n\t\t\tif( v == null )\n\t\t\t\treturn TNull;\n\t\t\tvar e = v.__enum__;\n\t\t\tif( e != null )\n\t\t\t\treturn TEnum(e);\n\t\t\tvar c = js.Boot.getClass(v);\n\t\t\tif( c != null )\n\t\t\t\treturn TClass(c);\n\t\t\treturn TObject;\n\t\tcase \"function\":\n\t\t\tif( js.Boot.isClass(v) || js.Boot.isEnum(v) )\n\t\t\t\treturn TObject;\n\t\t\treturn TFunction;\n\t\tcase \"undefined\":\n\t\t\treturn TNull;\n\t\tdefault:\n\t\t\treturn TUnknown;\n\t\t}\n\t}\n\n\tpublic static function enumEq<T>( a : T, b : T ) : Bool untyped {\n\t\tif( a == b )\n\t\t\treturn true;\n\t\ttry {\n\t\t\tif( a[0] != b[0] )\n\t\t\t\treturn false;\n\t\t\tfor( i in 2...a.length )\n\t\t\t\tif( !enumEq(a[i],b[i]) )\n\t\t\t\t\treturn false;\n\t\t\tvar e = a.__enum__;\n\t\t\tif( e != b.__enum__ || e == null )\n\t\t\t\treturn false;\n\t\t} catch( e : Dynamic ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic inline static function enumConstructor( e : EnumValue ) : String {\n\t\treturn untyped e[0];\n\t}\n\n\tpublic inline static function enumParameters( e : EnumValue ) : Array<Dynamic> {\n\t\treturn untyped e.slice(2);\n\t}\n\n\tpublic inline static function enumIndex( e : EnumValue ) : Int {\n\t\treturn untyped e[1];\n\t}\n\n\tpublic static function allEnums<T>( e : Enum<T> ) : Array<T> {\n\t\treturn untyped e.__empty_constructs__;\n\t}\n\n}\n\n","/*\n * Copyright (C)2005-2013 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tThe Timer class allows you to create asynchronous timers on platforms that\n\tsupport events.\n\n\tThe intended usage is to create an instance of the Timer class with a given\n\tinterval, set its run() method to a custom function to be invoked and\n\teventually call stop() to stop the Timer.\n\n\tNote that a running Timer may or may not prevent the program to exit\n\tautomatically when main() returns.\n\n\tIt is also possible to extend this class and override its run() method in\n\tthe child class.\n**/\nclass Timer {\n\t#if (flash || js || java || python)\n\n\t#if (flash || js)\n\t\tprivate var id : Null<Int>;\n\t#elseif java\n\t\tprivate var timer : java.util.Timer;\n\t\tprivate var task : java.util.TimerTask;\n\t#end\n\n\t/**\n\t\tCreates a new timer that will run every `time_ms` milliseconds.\n\n\t\tAfter creating the Timer instance, it calls `this].run` repeatedly,\n\t\twith delays of `time_ms` milliseconds, until `this.stop` is called.\n\n\t\tThe first invocation occurs after `time_ms` milliseconds, not\n\t\timmediately.\n\n\t\tThe accuracy of this may be platform-dependent.\n\t**/\n\tpublic function new( time_ms : Int ){\n\t\t#if flash\n\t\t\tvar me = this;\n\t\t\tid = untyped __global__[\"flash.utils.setInterval\"](function() { me.run(); },time_ms);\n\t\t#elseif js\n\t\t\tvar me = this;\n\t\t\tid = untyped setInterval(function() me.run(),time_ms);\n\t\t#elseif java\n\t\t\ttimer = new java.util.Timer();\n\t\t\ttimer.scheduleAtFixedRate(task = new TimerTask(this), haxe.Int64.ofInt(time_ms), haxe.Int64.ofInt(time_ms));\n\t\t#end\n\t}\n\n\t/**\n\t\tStops `this` Timer.\n\n\t\tAfter calling this method, no additional invocations of `this.run`\n\t\twill occur.\n\n\t\tIt is not possible to restart `this` Timer once stopped.\n\t**/\n\tpublic function stop() {\n\t\t#if (flash || js)\n\t\t\tif( id == null )\n\t\t\t\treturn;\n\t\t\t#if flash\n\t\t\t\tuntyped __global__[\"flash.utils.clearInterval\"](id);\n\t\t\t#elseif js\n\t\t\t\tuntyped clearInterval(id);\n\t\t\t#end\n\t\t\tid = null;\n\t\t#elseif java\n\t\t\ttimer.cancel();\n\t\t\ttimer = null;\n\t\t\ttask = null;\n\t\t#end\n\t}\n\n\t/**\n\t\tThis method is invoked repeatedly on `this` Timer.\n\n\t\tIt can be overridden in a subclass, or rebound directly to a custom\n\t\tfunction:\n\t\t\tvar timer = new haxe.Timer(1000); // 1000ms delay\n\t\t\ttimer.run = function() { ... }\n\n\t\tOnce bound, it can still be rebound to different functions until `this`\n\t\tTimer is stopped through a call to `this.stop`.\n\t**/\n\tpublic dynamic function run() {\n\n\t}\n\n\t/**\n\t\tInvokes `f` after `time_ms` milliseconds.\n\n\t\tThis is a convenience function for creating a new Timer instance with\n\t\t`time_ms` as argument, binding its run() method to `f` and then stopping\n\t\t`this` Timer upon the first invocation.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function delay( f : Void -> Void, time_ms : Int ) {\n\t\tvar t = new haxe.Timer(time_ms);\n\t\tt.run = function() {\n\t\t\tt.stop();\n\t\t\tf();\n\t\t};\n\t\treturn t;\n\t}\n\n\t#end\n\n\t/**\n\t\tMeasures the time it takes to execute `f`, in seconds with fractions.\n\n\t\tThis is a convenience function for calculating the difference between\n\t\tTimer.stamp() before and after the invocation of `f`.\n\n\t\tThe difference is passed as argument to Log.trace(), with \"s\" appended\n\t\tto denote the unit. The optional `pos` argument is passed through.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function measure<T>( f : Void -> T, ?pos : PosInfos ) : T {\n\t\tvar t0 = stamp();\n\t\tvar r = f();\n\t\tLog.trace((stamp() - t0) + \"s\", pos);\n\t\treturn r;\n\t}\n\n\t/**\n\t\tReturns a timestamp, in seconds with fractions.\n\n\t\tThe value itself might differ depending on platforms, only differences\n\t\tbetween two values make sense.\n\t**/\n\tpublic static function stamp() : Float {\n\t\t#if flash\n\t\t\treturn flash.Lib.getTimer() / 1000;\n\t\t#elseif (neko || php)\n\t\t\treturn Sys.time();\n\t\t#elseif js\n\t\t\treturn Date.now().getTime() / 1000;\n\t\t#elseif cpp\n\t\t\treturn untyped __global__.__time_stamp();\n\t\t#elseif sys\n\t\t\treturn Sys.time();\n\t\t#else\n\t\t\treturn 0;\n\t\t#end\n\t}\n\n}\n\n#if java\n@:nativeGen\nprivate class TimerTask extends java.util.TimerTask {\n\tvar timer:Timer;\n\tpublic function new(timer:Timer):Void {\n\t\tsuper();\n\t\tthis.timer = timer;\n\t}\n\n\t@:overload override public function run():Void {\n\t\ttimer.run();\n\t}\n}\n#end\n","/*\n * Copyright (C)2005-2013 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of h software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and h permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.ds;\n\n@:coreApi\nclass ObjectMap<K:{ }, V> implements haxe.Constraints.IMap<K,V> {\n\n\tstatic var count = 0;\n\n\tstatic inline function assignId(obj: { } ):Int {\n\t\treturn untyped obj.__id__ = ++count;\n\t}\n\n\tstatic inline function getId(obj: { } ):Int {\n\t\treturn untyped obj.__id__;\n\t}\n\n\tvar h : { };\n\n\tpublic function new() : Void {\n\t\th = { };\n\t\tuntyped h.__keys__ = { };\n\t}\n\n\tpublic function set(key:K, value:V):Void untyped {\n\t\tvar id : Int = untyped key.__id__ || assignId(key);\n\t\th[id] = value;\n\t\th.__keys__[id] = key;\n\t}\n\n\tpublic inline function get(key:K):Null<V> {\n\t\treturn untyped h[getId(key)];\n\t}\n\n\tpublic inline function exists(key:K):Bool {\n\t\treturn untyped h.__keys__[getId(key)] != null;\n\t}\n\n\tpublic function remove( key : K ) : Bool {\n\t\tvar id = getId(key);\n\t\tif ( untyped h.__keys__[id] == null ) return false;\n\t\tuntyped  __js__(\"delete\")(h[id]);\n\t\tuntyped  __js__(\"delete\")(h.__keys__[id]);\n\t\treturn true;\n\t}\n\n\tpublic function keys() : Iterator<K> {\n\t\tvar a = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h.__keys__ ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\ta.push(h.__keys__[key]);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a.iterator();\n\t}\n\n\tpublic function iterator() : Iterator<V> {\n\t\treturn untyped {\n\t\t\tref : h,\n\t\t\tit : keys(),\n\t\t\thasNext : function() { return __this__.it.hasNext(); },\n\t\t\tnext : function() { var i = __this__.it.next(); return __this__.ref[getId(i)]; }\n\t\t};\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar it = keys();\n\t\tfor( i in it ) {\n\t\t\ts.add(Std.string(i));\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(i)));\n\t\t\tif( it.hasNext() )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js;\n\nprivate class HaxeError extends js.Error {\n\n\tvar val:Dynamic;\n\n\tpublic function new(val:Dynamic) untyped {\n\t\tsuper();\n\t\tthis.val = __define_feature__(\"js.Boot.HaxeError\", val);\n\t\tthis.message = String(val);\n\t\tif (js.Error.captureStackTrace) js.Error.captureStackTrace(this, HaxeError);\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\n\tprivate static function __unhtml(s : String) {\n\t\treturn s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t}\n\n\tprivate static function __trace(v,i : haxe.PosInfos) {\n\t\tuntyped {\n\t\t\tvar msg = if( i != null ) i.fileName+\":\"+i.lineNumber+\": \" else \"\";\n\t\t\t#if jsfl\n\t\t\tmsg += __string_rec(v,\"\");\n\t\t\tfl.trace(msg);\n\t\t\t#else\n\t\t\tmsg += __string_rec(v, \"\");\n\t\t\tif( i != null && i.customParams != null )\n\t\t\t\tfor( v in i.customParams )\n\t\t\t\t\tmsg += \",\" + __string_rec(v, \"\");\n\t\t\tvar d;\n\t\t\tif( __js__(\"typeof\")(document) != \"undefined\" && (d = document.getElementById(\"haxe:trace\")) != null )\n\t\t\t\td.innerHTML += __unhtml(msg)+\"<br/>\";\n\t\t\telse if( __js__(\"typeof console\") != \"undefined\" && __js__(\"console\").log != null )\n\t\t\t\t__js__(\"console\").log(msg);\n\t\t\t#end\n\t\t}\n\t}\n\n\tprivate static function __clear_trace() {\n\t\tuntyped {\n\t\t\t#if jsfl\n\t\t\tfl.outputPanel.clear();\n\t\t\t#else\n\t\t\tvar d = document.getElementById(\"haxe:trace\");\n\t\t\tif( d != null )\n\t\t\t\td.innerHTML = \"\";\n\t\t\t#end\n\t\t}\n\t}\n\n\tstatic inline function isClass(o:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\tstatic function getClass(o:Dynamic) : Dynamic {\n\t\tif (Std.is(o, Array))\n\t\t\treturn Array;\n\t\telse {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o,s:String) {\n\t\tuntyped {\n\t\t\tif( o == null )\n\t\t\t    return \"null\";\n\t\t\tif( s.length >= 5 )\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = __js__(\"typeof(o)\");\n\t\t\tif( t == \"function\" && (isClass(o) || isEnum(o)) )\n\t\t\t\tt = \"object\";\n\t\t\tswitch( t ) {\n\t\t\tcase \"object\":\n\t\t\t\tif( __js__(\"o instanceof Array\") ) {\n\t\t\t\t\tif( o.__enum__ ) {\n\t\t\t\t\t\tif( o.length == 2 )\n\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\tvar str = o[0]+\"(\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor( i in 2...o.length ) {\n\t\t\t\t\t\t\tif( i != 2 )\n\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i],s);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tstr += __string_rec(o[i],s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tvar l = o.length;\n\t\t\t\t\tvar i;\n\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tfor( i in 0...l )\n\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\")+__string_rec(o[i],s);\n\t\t\t\t\tstr += \"]\";\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t\tvar tostr;\n\t\t\t\ttry {\n\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t} catch( e : Dynamic ) {\n\t\t\t\t\t// strange error on IE\n\t\t\t\t\treturn \"???\";\n\t\t\t\t}\n\t\t\t\tif( tostr != null && tostr != __js__(\"Object.toString\") && __typeof__(tostr) == \"function\" ) {\n\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\tif( s2 != \"[object Object]\")\n\t\t\t\t\t\treturn s2;\n\t\t\t\t}\n\t\t\t\tvar k : String = null;\n\t\t\t\tvar str = \"{\\n\";\n\t\t\t\ts += \"\\t\";\n\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t__js__(\"for( var k in o ) {\");\n\t\t\t\t\tif( hasp && !o.hasOwnProperty(k) )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\" )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( str.length != 2 )\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \"+__string_rec(o[k],s);\n\t\t\t\t__js__(\"}\");\n\t\t\t\ts = s.substring(1);\n\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\treturn str;\n\t\t\tcase \"function\":\n\t\t\t\treturn \"<function>\";\n\t\t\tcase \"string\":\n\t\t\t\treturn o;\n\t\t\tdefault:\n\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static function __interfLoop(cc : Dynamic,cl : Dynamic) {\n\t\tif( cc == null )\n\t\t\treturn false;\n\t\tif( cc == cl )\n\t\t\treturn true;\n\t\tvar intf : Dynamic = cc.__interfaces__;\n\t\tif( intf != null )\n\t\t\tfor( i in 0...intf.length ) {\n\t\t\t\tvar i : Dynamic = intf[i];\n\t\t\t\tif( i == cl || __interfLoop(i,cl) )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\treturn __interfLoop(cc.__super__,cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") private static function __instanceof(o : Dynamic,cl : Dynamic) {\n\t\tif( cl == null )\n\t\t\treturn false;\n\t\tswitch( cl ) {\n\t\tcase Int:\n\t\t\treturn (untyped __js__(\"(o|0) === o\"));\n\t\tcase Float:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"number\";\n\t\tcase Bool:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"boolean\";\n\t\tcase String:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"string\";\n\t\tcase Array:\n\t\t\treturn (untyped __js__(\"(o instanceof Array)\")) && o.__enum__ == null;\n\t\tcase Dynamic:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tif( o != null ) {\n\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\tif( (untyped __js__(\"typeof\"))(cl) == \"function\" ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") )\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif( __interfLoop(getClass(o),cl) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if ( (untyped __js__(\"typeof\"))(cl) == \"object\" && __isNativeObj(cl) ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// do not use isClass/isEnum here\n\t\t\tuntyped __feature__(\"Class.*\",if( cl == Class && o.__name__ != null ) return true);\n\t\t\tuntyped __feature__(\"Enum.*\",if( cl == Enum && o.__ename__ != null ) return true);\n\t\t\treturn o.__enum__ == cl;\n\t\t}\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o : Dynamic, t : Dynamic) {\n\t\tif (__instanceof(o, t)) return o;\n\t\telse throw \"Cannot cast \" +Std.string(o) + \" to \" +Std.string(t);\n\t}\n\n\tstatic var __toStr = untyped __js__(\"{}.toString\");\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name = untyped __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) untyped {\n\t\treturn untyped Function('return typeof $name != \"undefined\" ? $name : null')();\n\t}\n\n}\n","﻿package motion.actuators;\r\n\r\n\r\nimport motion.easing.IEasing;\r\nimport motion.Actuate;\r\n\r\n@:keepSub\r\n\r\n\r\nclass GenericActuator<T> implements IGenericActuator {\r\n\t\r\n\t\r\n\tprivate var duration:Float;\r\n\tprivate var id:String;\r\n\tprivate var properties:Dynamic;\r\n\tprivate var target:T;\r\n\tprivate var _autoVisible:Bool;\r\n\tprivate var _delay:Float;\r\n\tprivate var _ease:IEasing;\r\n\tprivate var _onComplete:Dynamic;\r\n\tprivate var _onCompleteParams:Array <Dynamic>;\r\n\tprivate var _onRepeat:Dynamic;\r\n\tprivate var _onRepeatParams:Array <Dynamic>;\r\n\tprivate var _onUpdate:Dynamic;\r\n\tprivate var _onUpdateParams:Array <Dynamic>;\r\n\tprivate var _onResume:Dynamic;\r\n\tprivate var _onResumeParams:Array <Dynamic>;\r\n\tprivate var _onPause:Dynamic;\r\n\tprivate var _onPauseParams:Array <Dynamic>;\r\n\tprivate var _reflect:Bool;\r\n\tprivate var _repeat:Int;\r\n\tprivate var _reverse:Bool;\r\n\tprivate var _smartRotation:Bool;\r\n\tprivate var _snapping:Bool;\r\n\tprivate var special:Bool;\r\n\t\r\n\t\r\n\tpublic function new (target:T, duration:Float, properties:Dynamic) {\r\n\t\t\r\n\t\t_autoVisible = true;\r\n\t\t_delay = 0;\r\n\t\t_reflect = false;\r\n\t\t_repeat = 0;\r\n\t\t_reverse = false;\r\n\t\t_smartRotation = false;\r\n\t\t_snapping = false;\r\n\t\tspecial = false;\r\n\t\t\r\n\t\tthis.target = target;\r\n\t\tthis.properties = properties;\r\n\t\tthis.duration = duration;\r\n\t\t\r\n\t\t_ease = Actuate.defaultEase;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate function apply ():Void {\r\n\t\t\r\n\t\tfor (i in Reflect.fields (properties)) {\r\n\t\t\t\r\n\t\t\t#if (haxe_209 || haxe3)\r\n\t\t\t\r\n\t\t\tif (#if flash false && #end Reflect.hasField (target, i)) {\r\n\t\t\t\t\r\n\t\t\t\tReflect.setField (target, i, Reflect.field (properties, i));\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\tReflect.setProperty (target, i, Reflect.field (properties, i));\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t#else\r\n\t\t\t\r\n\t\t\tReflect.setField (target, i, Reflect.field (properties, i));\r\n\t\t\t\r\n\t\t\t#end\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Flash performs faster when objects are set to visible = false rather than only alpha = 0. autoVisible toggles automatically based on alpha values\r\n\t * @param\tvalue\t\tWhether autoVisible should be enabled (Default is true)\r\n\t * @return\t\tThe current actuator instance\r\n\t */\r\n\tpublic function autoVisible (?value:Null<Bool>):GenericActuator<T> {\r\n\t\t\r\n\t\tif (value == null) {\r\n\t\t\t\r\n\t\t\tvalue = true;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t_autoVisible = value;\r\n\t\t\r\n\t\treturn this;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate inline function callMethod (method:Dynamic, params:Array<Dynamic> = null):Dynamic {\r\n\t\t\r\n\t\tif (params == null) {\r\n\t\t\t\r\n\t\t\tparams = [];\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t#if neko\r\n\t\t\r\n\t\tvar diff = untyped ($nargs)(method) - params.length;\r\n\t\t\r\n\t\tif (diff > 0) {\r\n\t\t\t\r\n\t\t\tparams = params.copy ();\r\n\t\t\t\r\n\t\t\tfor (i in 0...diff) {\r\n\t\t\t\t\r\n\t\t\t\tparams.push (null);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t#end\r\n\t\t\r\n\t\treturn Reflect.callMethod (method, method, params);\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate function change ():Void {\r\n\t\t\r\n\t\tif (_onUpdate != null) {\r\n\t\t\t\r\n\t\t\tcallMethod (_onUpdate, _onUpdateParams);\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate function complete (sendEvent:Bool = true):Void {\r\n\t\t\r\n\t\tif (sendEvent) {\r\n\t\t\t\r\n\t\t\tchange ();\r\n\t\t\t\r\n\t\t\tif (_onComplete != null) {\r\n\t\t\t\t\r\n\t\t\t\tcallMethod (_onComplete, _onCompleteParams);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tActuate.unload (this);\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Increases the delay before a tween is executed\r\n\t * @param\tduration\t\tThe amount of seconds to delay\r\n\t * @return\t\tThe current actuator instance\r\n\t */\r\n\tpublic function delay (duration:Float):GenericActuator<T> {\r\n\t\t\r\n\t\t_delay = duration;\r\n\t\t\r\n\t\treturn this;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Sets the easing which is used when running the tween\r\n\t * @param\teasing\t\tAn easing equation, like Elastic.easeIn or Quad.easeOut\r\n\t * @return\t\tThe current actuator instance\r\n\t */\r\n\tpublic function ease (easing:IEasing):GenericActuator<T> {\r\n\t\t\r\n\t\t_ease = easing;\r\n\t\t\r\n\t\treturn this;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate function move ():Void {\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Defines a function which will be called when the tween finishes\r\n\t * @param\thandler\t\tThe function you would like to be called\r\n\t * @param\tparameters\t\tParameters you would like to pass to the handler function when it is called\r\n\t * @return\t\tThe current actuator instance\r\n\t */\r\n\tpublic function onComplete (handler:Dynamic, parameters:Array <Dynamic> = null):GenericActuator<T> {\r\n\t\t\r\n\t\t_onComplete = handler;\r\n\t\t\r\n\t\tif (parameters == null) {\r\n\t\t\t\r\n\t\t\t_onCompleteParams = [];\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\t\r\n\t\t\t_onCompleteParams = parameters;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tif (duration == 0) {\r\n\t\t\t\r\n\t\t\tcomplete ();\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn this;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Defines a function which will be called when the tween repeats\r\n\t * @param\thandler\t\tThe function you would like to be called\r\n\t * @param\tparameters\t\tParameters you would like to pass to the handler function when it is called\r\n\t * @return\t\tThe current actuator instance\r\n\t */\r\n\tpublic function onRepeat (handler:Dynamic, parameters:Array <Dynamic> = null):GenericActuator<T> {\r\n\t\t\r\n\t\t_onRepeat = handler;\r\n\t\t\r\n\t\tif (parameters == null) {\r\n\t\t\t\r\n\t\t\t_onRepeatParams = [];\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\t\r\n\t\t\t_onRepeatParams = parameters;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn this;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Defines a function which will be called when the tween updates\r\n\t * @param\thandler\t\tThe function you would like to be called\r\n\t * @param\tparameters\t\tParameters you would like to pass to the handler function when it is called\r\n\t * @return\t\tThe current actuator instance\r\n\t */\r\n\tpublic function onUpdate (handler:Dynamic, parameters:Array <Dynamic> = null):GenericActuator<T> {\r\n\t\t\r\n\t\t_onUpdate = handler;\r\n\t\t\r\n\t\tif (parameters == null) {\r\n\t\t\t\r\n\t\t\t_onUpdateParams = [];\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\t\r\n\t\t\t_onUpdateParams = parameters;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn this;\r\n\t\t\r\n\t}\r\n\t\r\n\t/**\r\n\t * Defines a function which will be called when the tween is paused\r\n\t * @param\thandler\t\tThe function you would like to be called\r\n\t * @param\tparameters\t\tParameters you would like to pass to the handler function when it is called\r\n\t * @return\t\tThe current actuator instance\r\n\t */\r\n\tpublic function onPause (handler:Dynamic, parameters:Array <Dynamic> = null):GenericActuator<T> {\r\n\t\t\r\n\t\t_onPause = handler;\r\n\t\t\r\n\t\tif (parameters == null) {\r\n\t\t\t\r\n\t\t\t_onPauseParams = [];\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\t\r\n\t\t\t_onPauseParams = parameters;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn this;\r\n\t\t\r\n\t}\r\n\t\r\n\t/**\r\n\t * Defines a function which will be called when the tween resumed after pause\r\n\t * @param\thandler\t\tThe function you would like to be called\r\n\t * @param\tparameters\t\tParameters you would like to pass to the handler function when it is called\r\n\t * @return\t\tThe current actuator instance\r\n\t */\r\n\tpublic function onResume (handler:Dynamic, parameters:Array <Dynamic> = null):GenericActuator<T> {\r\n\t\t\r\n\t\t_onResume = handler;\r\n\t\t\r\n\t\tif (parameters == null) {\r\n\t\t\t\r\n\t\t\t_onResumeParams = [];\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\t\r\n\t\t\t_onResumeParams = parameters;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn this;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate function pause ():Void {\r\n\t\t\r\n\t\tif (_onPause != null)\r\n\t\t\tcallMethod(_onPause, _onPauseParams);\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Automatically changes the reverse value when the tween repeats. Repeat must be enabled for this to have any effect\r\n\t * @param\tvalue\t\tWhether reflect should be enabled (Default is true)\r\n\t * @return\t\tThe current actuator instance\r\n\t */\r\n\tpublic function reflect (?value:Null<Bool>):GenericActuator<T> {\r\n\t\t\r\n\t\tif (value == null) {\r\n\t\t\t\r\n\t\t\tvalue = true;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t_reflect = value;\r\n\t\tspecial = true;\r\n\t\t\r\n\t\treturn this;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Repeats the tween after it finishes\r\n\t * @param\ttimes\t\tThe number of times you would like the tween to repeat, or -1 if you would like to repeat the tween indefinitely (Default is -1)\r\n\t * @return\t\tThe current actuator instance\r\n\t */\r\n\tpublic function repeat (?times:Null<Int>):GenericActuator<T> {\r\n\t\t\r\n\t\tif (times == null) {\r\n\t\t\t\r\n\t\t\ttimes = -1;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t_repeat = times;\r\n\t\t\r\n\t\treturn this;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate function resume ():Void {\r\n\t\t\r\n\t\tif (_onResume != null)\r\n\t\t\tcallMethod(_onResume, _onResumeParams);\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Sets if the tween should be handled in reverse\r\n\t * @param\tvalue\t\tWhether the tween should be reversed (Default is true)\r\n\t * @return\t\tThe current actuator instance\r\n\t */\r\n\tpublic function reverse (?value:Null<Bool>):GenericActuator<T> {\r\n\t\t\r\n\t\tif (value == null) {\r\n\t\t\t\r\n\t\t\tvalue = true;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t_reverse = value;\r\n\t\tspecial = true;\r\n\t\t\r\n\t\treturn this;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Enabling smartRotation can prevent undesired results when tweening rotation values\r\n\t * @param\tvalue\t\tWhether smart rotation should be enabled (Default is true)\r\n\t * @return\t\tThe current actuator instance\r\n\t */\r\n\tpublic function smartRotation (?value:Null<Bool>):GenericActuator<T> {\r\n\t\t\r\n\t\tif (value == null) {\r\n\t\t\t\r\n\t\t\tvalue = true;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t_smartRotation = value;\r\n\t\tspecial = true;\r\n\t\t\r\n\t\treturn this;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Snapping causes tween values to be rounded automatically\r\n\t * @param\tvalue\t\tWhether tween values should be rounded (Default is true)\r\n\t * @return\t\tThe current actuator instance\r\n\t */\r\n\tpublic function snapping (?value:Null<Bool>):GenericActuator<T> {\r\n\t\t\r\n\t\tif (value == null) {\r\n\t\t\t\r\n\t\t\tvalue = true;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t_snapping = value;\r\n\t\tspecial = true;\r\n\t\t\r\n\t\treturn this;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate function stop (properties:Dynamic, complete:Bool, sendEvent:Bool):Void {\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n}","﻿package motion.actuators;\r\n\r\n\r\nimport motion.actuators.GenericActuator;\r\n#if (flash || nme || openfl)\r\nimport flash.display.DisplayObject;\r\nimport flash.events.Event;\r\nimport flash.Lib;\r\n#elseif lime\r\nimport lime.app.Application;\r\nimport lime.system.System;\r\n#else\r\n#if neko\r\nimport haxe.Log;\r\nimport haxe.PosInfos;\r\n#end\r\nimport haxe.Timer;\r\n#end\r\n\r\n\r\nclass SimpleActuator<T, U> extends GenericActuator<T> {\r\n\t\r\n\t\r\n\t#if actuate_manual_time\r\n\tpublic static var getTime:Void->Float;\r\n\t#end\r\n\t\r\n\tprivate var timeOffset:Float;\r\n\t\r\n\tprivate static var actuators = new Array<SimpleActuator<Dynamic, Dynamic>> ();\r\n\tprivate static var actuatorsLength = 0;\r\n\tprivate static var addedEvent = false;\r\n\t\r\n\t#if (!flash && !nme && !openfl && !lime)\r\n\tprivate static var timer:Timer;\r\n\t#end\r\n\t\r\n\tprivate var active:Bool;\r\n\tprivate var cacheVisible:Bool;\r\n\tprivate var detailsLength:Int;\r\n\tprivate var initialized:Bool;\r\n\tprivate var paused:Bool;\r\n\tprivate var pauseTime:Float;\r\n\tprivate var propertyDetails:Array <PropertyDetails<U>>;\r\n\tprivate var sendChange:Bool;\r\n\tprivate var setVisible:Bool;\r\n\tprivate var startTime:Float;\r\n\tprivate var toggleVisible:Bool;\r\n\t\r\n\t\r\n\tpublic function new (target:T, duration:Float, properties:Dynamic) {\r\n\t\t\r\n\t\tactive = true;\r\n\t\tpropertyDetails = new Array ();\r\n\t\tsendChange = false;\r\n\t\tpaused = false;\r\n\t\tcacheVisible = false;\r\n\t\tinitialized = false;\r\n\t\tsetVisible = false;\r\n\t\ttoggleVisible = false;\r\n\t\t\r\n\t\t#if !actuate_manual_time\r\n\t\t\t#if (flash || nme || openfl)\r\n\t\t\tstartTime = Lib.getTimer () / 1000;\r\n\t\t\t#elseif lime\r\n\t\t\tstartTime = System.getTimer () / 1000;\r\n\t\t\t#else\r\n\t\t\tstartTime = Timer.stamp ();\r\n\t\t\t#end\r\n\t\t#else\r\n\t\tstartTime = getTime();\r\n\t\t#end\r\n\t\t\r\n\t\tsuper (target, duration, properties);\r\n\t\t\r\n\t\tif (!addedEvent) {\r\n\t\t\t\r\n\t\t\taddedEvent = true;\r\n\t\t\t#if !actuate_manual_update\r\n\t\t\t\t#if (flash || nme || openfl)\r\n\t\t\t\tLib.current.stage.addEventListener (Event.ENTER_FRAME, stage_onEnterFrame);\r\n\t\t\t\t#elseif lime\r\n\t\t\t\tApplication.current.onUpdate.add (stage_onEnterFrame);\r\n\t\t\t\t#else\r\n\t\t\t\ttimer = new Timer (Std.int(1000 / 30));\r\n\t\t\t\ttimer.run = stage_onEnterFrame;\r\n\t\t\t\t#end\r\n\t\t\t#end\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @inheritDoc\r\n\t */\r\n\tpublic override function autoVisible (?value:Null<Bool>):GenericActuator<T> {\r\n\t\t\r\n\t\tif (value == null) {\r\n\t\t\t\r\n\t\t\tvalue = true;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t_autoVisible = value;\r\n\t\t\r\n\t\tif (!value) {\r\n\t\t\t\r\n\t\t\ttoggleVisible = false;\r\n\t\t\t\r\n\t\t\tif (setVisible) {\r\n\t\t\t\t\r\n\t\t\t\tsetField (target, \"visible\", cacheVisible);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn this;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @inheritDoc\r\n\t */\r\n\tpublic override function delay (duration:Float):GenericActuator<T> {\r\n\t\t\r\n\t\t_delay = duration;\r\n\t\ttimeOffset = startTime + duration;\r\n\t\t\r\n\t\treturn this;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate inline function getField<V> (target:V, propertyName:String):Dynamic {\r\n\t\t\r\n\t\t#if (haxe_209 || haxe3)\r\n\t\t\r\n\t\tvar value = null;\r\n\t\t\r\n\t\tif (Reflect.hasField (target, propertyName)) {\r\n\t\t\t\r\n\t\t\t#if flash\r\n\t\t\tvalue = untyped target[propertyName];\r\n\t\t\t#else\r\n\t\t\tvalue = Reflect.field (target, propertyName);\r\n\t\t\t#end\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\t\r\n\t\t\tvalue = Reflect.getProperty (target, propertyName);\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn value;\r\n\t\t\r\n\t\t#else\r\n\t\t\r\n\t\treturn Reflect.field (target, propertyName);\r\n\t\t\r\n\t\t#end\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate function initialize ():Void {\r\n\t\t\r\n\t\tvar details:PropertyDetails<U>;\r\n\t\tvar start:Dynamic;\r\n\t\t\r\n\t\tfor (i in Reflect.fields (properties)) {\r\n\t\t\t\r\n\t\t\tvar isField = true;\r\n\t\t\t\r\n\t\t\t#if (haxe_209 || haxe3)\r\n\t\t\t\r\n\t\t\tif (Reflect.hasField (target, i) #if flash && !untyped (target).hasOwnProperty (\"set_\" + i) #elseif html5 && !(untyped (target).__properties__ && untyped (target).__properties__[\"set_\" + i]) #end) {\r\n\t\t\t\t\r\n\t\t\t\tstart = Reflect.field (target, i);\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\tisField = false;\r\n\t\t\t\tstart = Reflect.getProperty (target, i);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t#else\r\n\t\t\t\r\n\t\t\tstart = Reflect.field (target, i);\r\n\t\t\t\r\n\t\t\t#end\r\n\t\t\t\r\n\t\t\tif (Std.is (start, Float)) {\r\n\t\t\t\t\r\n\t\t\t\tvar value:Dynamic = getField (properties, i);\r\n\t\t\t\t\r\n\t\t\t\t#if (neko || js)\r\n\t\t\t\tif (start == null) start = 0;\r\n\t\t\t\tif (value == null) value = 0;\r\n\t\t\t\t#end\r\n\t\t\t\t\r\n\t\t\t\tdetails = new PropertyDetails (cast target, i, start, value - start, isField);\r\n\t\t\t\tpropertyDetails.push (details);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tdetailsLength = propertyDetails.length;\r\n\t\tinitialized = true;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate override function move ():Void {\r\n\t\t\r\n\t\t#if (flash || nme || openfl)\r\n\t\ttoggleVisible = (Reflect.hasField (properties, \"alpha\") && Std.is (target, DisplayObject));\r\n\t\t#else\r\n\t\ttoggleVisible = (Reflect.hasField (properties, \"alpha\") && Reflect.hasField (properties, \"visible\"));\r\n\t\t#end\r\n\t\t\r\n\t\tif (toggleVisible && properties.alpha != 0 && !getField (target, \"visible\")) {\r\n\t\t\t\r\n\t\t\tsetVisible = true;\r\n\t\t\tcacheVisible = getField (target, \"visible\");\r\n\t\t\tsetField (target, \"visible\", true);\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\ttimeOffset = startTime;\r\n\t\tactuators.push (this);\r\n\t\t++actuatorsLength;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @inheritDoc\r\n\t */\r\n\tpublic override function onUpdate (handler:Dynamic, parameters:Array <Dynamic> = null):GenericActuator<T> {\r\n\t\t\r\n\t\t_onUpdate = handler;\r\n\t\t\r\n\t\tif (parameters == null) {\r\n\t\t\t\r\n\t\t\t_onUpdateParams = [];\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\t\r\n\t\t\t_onUpdateParams = parameters;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tsendChange = true;\r\n\t\t\r\n\t\treturn this;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate override function pause ():Void {\r\n\t\t\r\n\t\tif (!paused)\r\n\t\t{\r\n\t\t\tpaused = true;\r\n\t\t\r\n\t\t\tsuper.pause();\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t#if !actuate_manual_time\r\n\t\t\t\t#if (flash || nme || openfl)\r\n\t\t\t\tpauseTime = Lib.getTimer ();\r\n\t\t\t\t#elseif lime\r\n\t\t\t\tpauseTime = System.getTimer ();\r\n\t\t\t\t#else\r\n\t\t\t\tpauseTime = Timer.stamp ();\r\n\t\t\t\t#end\r\n\t\t\t#else\r\n\t\t\tpauseTime = getTime();\r\n\t\t\t#end\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate override function resume ():Void {\r\n\t\t\r\n\t\tif (paused) {\r\n\t\t\t\r\n\t\t\tpaused = false;\r\n\t\t\t\r\n\t\t\t#if !actuate_manual_time\r\n\t\t\t\t#if (flash || nme || openfl)\r\n\t\t\t\ttimeOffset += (Lib.getTimer () - pauseTime) / 1000;\r\n\t\t\t\t#elseif lime\r\n\t\t\t\ttimeOffset += (System.getTimer () - pauseTime) / 1000;\r\n\t\t\t\t#else\r\n\t\t\t\ttimeOffset += (Timer.stamp () - pauseTime);\r\n\t\t\t\t#end\r\n\t\t\t#else\r\n\t\t\ttimeOffset += (getTime() - pauseTime) / 1000;\r\n\t\t\t#end\r\n\t\t\t\r\n\t\t\tsuper.resume();\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t@:generic private inline function setField<V> (target:V, propertyName:String, value:Dynamic):Void {\r\n\t\t\r\n\t\tif (Reflect.hasField (target, propertyName)) {\r\n\t\t\t\r\n\t\t\t#if flash\r\n\t\t\tuntyped target[propertyName] = value;\r\n\t\t\t#else\r\n\t\t\tReflect.setField (target, propertyName, value);\r\n\t\t\t#end\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\t\r\n\t\t\t#if (haxe_209 || haxe3)\r\n\t\t\tReflect.setProperty (target, propertyName, value);\r\n\t\t\t#end\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate inline function setProperty (details:PropertyDetails<U>, value:Dynamic):Void {\r\n\t\t\r\n\t\tif (details.isField) {\r\n\t\t\t\r\n\t\t\t#if flash\r\n\t\t\tuntyped details.target[details.propertyName] = value;\r\n\t\t\t#else\r\n\t\t\tReflect.setField (details.target, details.propertyName, value);\r\n\t\t\t#end\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\t\r\n\t\t\t#if (haxe_209 || haxe3)\r\n\t\t\tReflect.setProperty (details.target, details.propertyName, value);\r\n\t\t\t#end\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate override function stop (properties:Dynamic, complete:Bool, sendEvent:Bool):Void {\r\n\t\t\r\n\t\tif (active) {\r\n\t\t\t\r\n\t\t\tif (properties == null) {\r\n\t\t\t\t\r\n\t\t\t\tactive = false;\r\n\t\t\t\t\r\n\t\t\t\tif (complete) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tapply ();\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tthis.complete (sendEvent);\r\n\t\t\t\treturn;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (i in Reflect.fields (properties)) {\r\n\t\t\t\t\r\n\t\t\t\tif (Reflect.hasField (this.properties, i)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tactive = false;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (complete) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tapply ();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tthis.complete (sendEvent);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate function update (currentTime:Float):Void {\r\n\t\t\r\n\t\tif (!paused) {\r\n\t\t\t\r\n\t\t\tvar details:PropertyDetails<U>;\r\n\t\t\tvar easing:Float;\r\n\t\t\tvar i:Int;\r\n\t\t\t\r\n\t\t\tvar tweenPosition:Float = (currentTime - timeOffset) / duration;\r\n\t\t\t\r\n\t\t\tif (tweenPosition > 1) {\r\n\t\t\t\t\r\n\t\t\t\ttweenPosition = 1;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (!initialized) {\r\n\t\t\t\t\r\n\t\t\t\tinitialize ();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (!special) {\r\n\t\t\t\t\r\n\t\t\t\teasing = _ease.calculate (tweenPosition);\r\n\t\t\t\t\r\n\t\t\t\tfor (i in 0...detailsLength) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tdetails = propertyDetails[i];\r\n\t\t\t\t\tsetProperty (details, details.start + (details.change * easing));\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\tif (!_reverse) {\r\n\t\t\t\t\t\r\n\t\t\t\t\teasing = _ease.calculate (tweenPosition);\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\teasing = _ease.calculate (1 - tweenPosition);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar endValue:Float;\r\n\t\t\t\t\r\n\t\t\t\tfor (i in 0...detailsLength) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tdetails = propertyDetails[i];\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (_smartRotation && (details.propertyName == \"rotation\" || details.propertyName == \"rotationX\" || details.propertyName == \"rotationY\" || details.propertyName == \"rotationZ\")) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar rotation:Float = details.change % 360;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (rotation > 180) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\trotation -= 360;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t} else if (rotation < -180) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\trotation += 360;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tendValue = details.start + rotation * easing;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tendValue = details.start + (details.change * easing);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (!_snapping) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tsetProperty (details, endValue);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tsetProperty (details, Math.round (endValue));\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (tweenPosition == 1) {\r\n\t\t\t\t\r\n\t\t\t\tif (_repeat == 0) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tactive = false;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (toggleVisible && getField (target, \"alpha\") == 0) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tsetField (target, \"visible\", false);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tcomplete (true);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (_onRepeat != null) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcallMethod (_onRepeat, _onRepeatParams);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (_reflect) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t_reverse = !_reverse;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tstartTime = currentTime;\r\n\t\t\t\t\ttimeOffset = startTime + _delay;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (_repeat > 0) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t_repeat --;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (sendChange) {\r\n\t\t\t\t\r\n\t\t\t\tchange ();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t// Event Handlers\r\n\t\r\n\t\r\n\t#if actuate_manual_update \r\n\tpublic \r\n\t#else \r\n\tprivate \r\n\t#end\r\n\tstatic function stage_onEnterFrame (#if (flash || nme || openfl) event:Event #elseif lime deltaTime:Int #end):Void {\r\n\t\t\r\n\t\t#if !actuate_manual_time\r\n\t\t\t#if (flash || nme || openfl)\r\n\t\t\tvar currentTime:Float = Lib.getTimer () / 1000;\r\n\t\t\t#elseif lime\r\n\t\t\tvar currentTime = System.getTimer () / 1000;\r\n\t\t\t#else\r\n\t\t\tvar currentTime = Timer.stamp ();\r\n\t\t\t#end\r\n\t\t#else\r\n\t\t\tvar currentTime = getTime();\r\n\t\t#end\r\n\t\t\r\n\t\tvar actuator:SimpleActuator<Dynamic, Dynamic>;\r\n\t\t\r\n\t\tvar j:Int = 0;\r\n\t\tvar cleanup = false;\r\n\t\t\r\n\t\tfor (i in 0...actuatorsLength) {\r\n\t\t\t\r\n\t\t\tactuator = actuators[j];\r\n\t\t\t\r\n\t\t\tif (actuator != null && actuator.active) {\r\n\t\t\t\t\r\n\t\t\t\tif (currentTime >= actuator.timeOffset) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tactuator.update (currentTime);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tj++;\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\tactuators.splice (j, 1);\r\n\t\t\t\t--actuatorsLength;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n}\r\n\r\n\r\n#if (!nme && neko || !nme && cpp)\r\n\r\n// Custom haxe.Timer implementation for C++ and Neko\r\n\r\ntypedef TimerList = Array <Timer>;\r\n\r\n\r\nclass Timer {\r\n\t\r\n\t\r\n\tstatic var sRunningTimers:TimerList = [];\r\n\t\r\n\tvar mTime:Float;\r\n\tvar mFireAt:Float;\r\n\tvar mRunning:Bool;\r\n\t\r\n\t\r\n\tpublic function new (time:Float) {\r\n\t\t\r\n\t\tmTime = time;\r\n\t\tsRunningTimers.push (this);\r\n\t\tmFireAt = GetMS () + mTime;\r\n\t\tmRunning = true;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tpublic static function measure<T>( f : Void -> T, ?pos : haxe.PosInfos ) : T {\r\n\t\tvar t0 = stamp();\r\n\t\tvar r = f();\r\n\t\thaxe.Log.trace((stamp() - t0) + \"s\", pos);\r\n\t\treturn r;\r\n\t}\r\n\t\r\n\t\r\n\t// Set this with \"run=...\"\r\n\tdynamic public function run () {\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t}\r\n   \r\n\t\r\n\tpublic function stop ():Void {\r\n\t\t\r\n\t\tif (mRunning) {\r\n\t\t\t\r\n\t\t\tmRunning = false;\r\n\t\t\tsRunningTimers.remove (this);\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tstatic function GetMS ():Float {\r\n\t\t\r\n\t\treturn stamp () * 1000.0;\r\n\t\t\r\n\t}\r\n\t\r\n\r\n   // From std/haxe/Timer.hx\r\n\tpublic static function delay (f:Void -> Void, time:Int) {\r\n\t\t\r\n\t\tvar t = new Timer (time);\r\n\t\t\r\n\t\tt.run = function () {\r\n\t\t\tt.stop ();\r\n\t\t\tf ();\r\n\t\t};\r\n\t\t\r\n\t\treturn t;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tstatic public function stamp ():Float {\r\n\t\t\r\n\t\treturn Date.now().getTime ();\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n}\r\n\r\n\r\n#end\r\n","﻿/**\r\n * @author Joshua Granick\r\n * @author Robert Penner / http://www.robertpenner.com/easing_terms_of_use.html\r\n */\r\n\r\n\r\npackage motion.easing;\r\n\r\n\r\n\r\nclass Expo {\r\n\t\r\n\t\r\n\tstatic public var easeIn (get_easeIn, never):IEasing;\r\n\tstatic public var easeInOut (get_easeInOut, never):IEasing;\r\n\tstatic public var easeOut (get_easeOut, never):IEasing;\r\n\t\r\n\t\r\n\tprivate static function get_easeIn ():IEasing {\r\n\t\t\r\n\t\treturn new ExpoEaseIn ();\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate static function get_easeInOut ():IEasing {\r\n\t\t\r\n\t\treturn new ExpoEaseInOut ();\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate static function get_easeOut ():IEasing {\r\n\t\t\r\n\t\treturn new ExpoEaseOut ();\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n}\r\n\r\n\r\nclass ExpoEaseIn implements IEasing {\r\n\t\r\n\t\r\n\tpublic function new () {\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tpublic function calculate (k:Float):Float {\r\n\t\t\r\n\t\treturn k == 0 ? 0 : Math.pow(2, 10 * (k - 1));\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tpublic function ease (t:Float, b:Float, c:Float, d:Float):Float {\r\n\t\t\r\n\t\treturn t == 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n}\r\n\r\n\r\nclass ExpoEaseInOut implements IEasing {\r\n\t\r\n\t\r\n\tpublic function new () {\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tpublic function calculate (k:Float):Float {\r\n\t\t\r\n\t\tif (k == 0) { return 0; }\r\n\t\tif (k == 1) { return 1; }\r\n\t\tif ((k /= 1 / 2.0) < 1.0) {\r\n\t\t\treturn 0.5 * Math.pow(2, 10 * (k - 1));\r\n\t\t}\r\n\t\treturn 0.5 * (2 - Math.pow(2, -10 * --k));\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tpublic function ease (t:Float, b:Float, c:Float, d:Float):Float {\r\n\t\t\r\n\t\tif (t == 0) {\r\n\t\t\treturn b;\r\n\t\t}\r\n\t\tif (t == d) {\r\n\t\t\treturn b + c;\r\n\t\t}\r\n\t\tif ((t /= d / 2.0) < 1.0) {\r\n\t\t\treturn c / 2 * Math.pow(2, 10 * (t - 1)) + b;\r\n\t\t}\r\n\t\treturn c / 2 * (2 - Math.pow(2, -10 * --t)) + b;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n}\r\n\r\n\r\nclass ExpoEaseOut implements IEasing {\r\n\t\r\n\t\r\n\tpublic function new () {\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tpublic function calculate (k:Float):Float {\r\n\t\t\r\n\t\treturn k == 1 ? 1 : (1 - Math.pow(2, -10 * k));\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tpublic function ease (t:Float, b:Float, c:Float, d:Float):Float {\r\n\t\t\r\n\t\treturn t == d ? b + c : c * (1 - Math.pow(2, -10 * t / d)) + b;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n}","﻿package motion;\r\n\r\n\r\nimport haxe.ds.ObjectMap;\r\nimport motion.actuators.FilterActuator;\r\nimport motion.actuators.GenericActuator;\r\nimport motion.actuators.IGenericActuator;\r\nimport motion.actuators.MethodActuator;\r\nimport motion.actuators.MotionPathActuator;\r\nimport motion.actuators.SimpleActuator;\r\nimport motion.actuators.TransformActuator;\r\nimport motion.easing.Expo;\r\nimport motion.easing.IEasing;\r\n#if (flash || nme || openfl)\r\nimport flash.display.DisplayObject;\r\n#end\r\n\r\n@:access(motion.actuators)\r\n\r\n\r\nclass Actuate {\r\n\t\r\n\t\r\n\tpublic static var defaultActuator:Class<IGenericActuator> = SimpleActuator;\r\n\tpublic static var defaultEase:IEasing = Expo.easeOut;\r\n\tprivate static var targetLibraries = new ObjectMap<Dynamic, Array<IGenericActuator>> ();\r\n\t#if neko\r\n\tprivate static var methodLibraries = new FunctionMap<Dynamic, Array<IGenericActuator>> ();\r\n\t#end\r\n\t\r\n\t\r\n\t/**\r\n\t * Copies properties from one object to another. Conflicting tweens are stopped automatically\r\n\t * @example\t\t<code>Actuate.apply (MyClip, { alpha: 1 } );</code>\r\n\t * @param\ttarget\t\tThe object to copy to\r\n\t * @param\tproperties\t\tThe object to copy from\r\n\t * @param\tcustomActuator\t\tA custom actuator to use instead of the default (Optional)\r\n\t * @return\t\tThe current actuator instance, which can be used to apply properties like onComplete or onUpdate handlers\r\n\t */\r\n\t/*@:generic*/ public static function apply<T> (target:T, properties:Dynamic, customActuator:Class<GenericActuator<T>> = null):GenericActuator<T> {\r\n\t\t\r\n\t\tstop (target, properties);\r\n\t\t\r\n\t\tif (customActuator == null) {\r\n\t\t\t\r\n\t\t\tcustomActuator = cast defaultActuator;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tvar actuator:GenericActuator<T> = Type.createInstance (customActuator, [ target, 0, properties ]);\r\n\t\tactuator.apply ();\r\n\t\t\r\n\t\treturn actuator;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t#if (flash || nme || openfl)\r\n\t\r\n\t/**\r\n\t * Creates a new effects tween \r\n\t * @param\ttarget\t\tThe object to tween\r\n\t * @param\tduration\t\tThe length of the tween in seconds\r\n\t * @param\toverwrite\t\tSets whether previous tweens for the same target and properties will be overwritten (Default is true)\r\n\t * @return\t\tAn EffectsOptions instance, which is used to select the kind of effect you would like to apply to the target\r\n\t */\r\n\tpublic static function effects (target:DisplayObject, duration:Float, overwrite:Bool = true):EffectsOptions {\r\n\t\t\r\n\t\treturn new EffectsOptions (target, duration, overwrite);\r\n\t\t\r\n\t}\r\n\t\r\n\t#end\r\n\t\r\n\t\r\n\tprivate static function getLibrary<T> (target:T, allowCreation:Bool = true):Array<IGenericActuator> {\r\n\t\t\r\n\t\t#if neko\r\n\t\t\r\n\t\tif (Reflect.isFunction (target)) {\r\n\t\t\t\r\n\t\t\tif (!methodLibraries.exists (target) && allowCreation) {\r\n\t\t\t\t\r\n\t\t\t\tmethodLibraries.set (target, new Array<IGenericActuator> ());\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn methodLibraries.get (target);\r\n\t\t\t\r\n\t\t}\r\n\t\t\t\r\n\t\t#end\r\n\t\t\r\n\t\tif (!targetLibraries.exists (target) && allowCreation) {\r\n\t\t\t\r\n\t\t\ttargetLibraries.set (target, new Array<IGenericActuator> ());\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn targetLibraries.get (target);\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Checks if Actuate has any active tweens \r\n\t * @return\t\tWhether Actuate is active\r\n\t */\r\n\tpublic static function isActive ():Bool {\r\n\t\t\r\n\t\tvar result = false;\r\n\t\t\r\n\t\tfor (library in targetLibraries) {\r\n\t\t\t\r\n\t\t\tresult = true;\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Creates a new MotionPath tween\r\n\t * @param\ttarget\t\tThe object to tween\r\n\t * @param\tduration\t\tThe length of the tween in seconds\r\n\t * @param\tproperties\t\tAn object containing a motion path for each property you wish to tween\r\n\t * @param\toverwrite\t\tSets whether previous tweens for the same target and properties will be overwritten (Default is true)\r\n\t * @return\t\tThe current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate\r\n\t */\r\n\t/*@:generic*/ public static function motionPath<T> (target:T, duration:Float, properties:Dynamic, overwrite:Bool = true):GenericActuator<T> {\r\n\t\t\r\n\t\treturn tween (target, duration, properties, overwrite, MotionPathActuator);\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Pauses tweens for the specified target objects\r\n\t * @param\t... targets\t\tThe target objects which will have their tweens paused. Passing no value pauses tweens for all objects\r\n\t */\r\n\t///*@:generic*/ public static function pause (... targets:Array):void {\r\n\t/*@:generic*/ public static function pause<T> (target:T):Void {\r\n\t\t\r\n\t\tif (Std.is (target, IGenericActuator)) {\r\n\t\t\t\r\n\t\t\tvar actuator:IGenericActuator = cast target;\r\n\t\t\tactuator.pause ();\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\t\r\n\t\t\tvar library = getLibrary (target, false);\r\n\t\t\t\r\n\t\t\tif (library != null) {\r\n\t\t\t\t\r\n\t\t\t\tfor (actuator in library) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tactuator.pause ();\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tpublic static function pauseAll ():Void {\r\n\t\t\r\n\t\t#if neko\r\n\t\t\r\n\t\tfor (library in methodLibraries) {\r\n\t\t\t\r\n\t\t\tfor (actuator in library) {\r\n\t\t\t\t\r\n\t\t\t\tactuator.pause ();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t#end\r\n\t\t\r\n\t\tfor (library in targetLibraries) {\r\n\t\t\t\r\n\t\t\tfor (actuator in library) {\r\n\t\t\t\t\r\n\t\t\t\tactuator.pause ();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Resets Actuate by stopping and removing tweens for all objects\r\n\t */\r\n\tpublic static function reset ():Void {\r\n\t\t\r\n\t\t#if neko\r\n\t\t\r\n\t\tfor (library in methodLibraries) {\r\n\t\t\t\r\n\t\t\tvar i = library.length - 1;\r\n\t\t\t\r\n\t\t\twhile (i >= 0) {\r\n\t\t\t\t\r\n\t\t\t\tlibrary[i].stop (null, false, false);\r\n\t\t\t\ti--;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tmethodLibraries = new FunctionMap<Dynamic, Array<IGenericActuator>> ();\r\n\t\t\r\n\t\t#end\r\n\t\t\r\n\t\tfor (library in targetLibraries) {\r\n\t\t\t\r\n\t\t\tvar i = library.length - 1;\r\n\t\t\t\r\n\t\t\twhile (i >= 0) {\r\n\t\t\t\t\r\n\t\t\t\tlibrary[i].stop (null, false, false);\r\n\t\t\t\ti--;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\ttargetLibraries = new ObjectMap<Dynamic, Array<IGenericActuator>> ();\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Resumes paused tweens for the specified target objects\r\n\t * @param\t... targets\t\tThe target objects which will have their tweens resumed. Passing no value resumes tweens for all objects\r\n\t */\r\n\t/*@:generic*/ public static function resume<T> (target:T):Void {\r\n\t\t\r\n\t\tif (Std.is (target, IGenericActuator)) {\r\n\t\t\t\r\n\t\t\tvar actuator:IGenericActuator = cast target;\r\n\t\t\tactuator.resume ();\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\t\r\n\t\t\tvar library = getLibrary (target, false);\r\n\t\t\t\r\n\t\t\tif (library != null) {\r\n\t\t\t\t\r\n\t\t\t\tfor (actuator in library) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tactuator.resume ();\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tpublic static function resumeAll ():Void {\r\n\t\t\r\n\t\t#if neko\r\n\t\t\r\n\t\tfor (library in methodLibraries) {\r\n\t\t\t\r\n\t\t\tfor (actuator in library) {\r\n\t\t\t\t\r\n\t\t\t\tactuator.resume ();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t#end\r\n\t\t\r\n\t\tfor (library in targetLibraries) {\r\n\t\t\t\r\n\t\t\tfor (actuator in library) {\r\n\t\t\t\t\r\n\t\t\t\tactuator.resume ();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Stops all tweens for an individual object\r\n\t * @param\ttarget\t\tThe target object which will have its tweens stopped, or a generic actuator instance\r\n\t * @param\tproperties\t\tA string, array or object which contains the properties you wish to stop, like \"alpha\", [ \"x\", \"y\" ] or { alpha: null }. Passing no value removes all tweens for the object (Optional)\r\n\t * @param\tcomplete\t\tIf tweens should apply their final target values before stopping. Default is false (Optional) \r\n\t * @param\tsendEvent\tIf a complete() event should be dispatched for the specified target. Default is true (Optional)\r\n\t */\r\n\t/*@:generic*/ public static function stop<T> (target:T, properties:Dynamic = null, complete:Bool = false, sendEvent:Bool = true):Void {\r\n\t\t\r\n\t\tif (target != null) {\r\n\t\t\t\r\n\t\t\tif (Std.is (target, IGenericActuator)) {\r\n\t\t\t\t\r\n\t\t\t\tvar actuator:IGenericActuator = cast target;\r\n\t\t\t\tactuator.stop (null, complete, sendEvent);\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\tvar library = getLibrary (target, false);\r\n\t\t\t\t\r\n\t\t\t\tif (library != null) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (Std.is (properties, String)) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar temp = { };\r\n\t\t\t\t\t\tReflect.setField (temp, properties, null);\r\n\t\t\t\t\t\tproperties = temp;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else if (Std.is (properties, Array)) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar temp = {};\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tfor (property in cast (properties, Array <Dynamic>)) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tReflect.setField (temp, property, null);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tproperties = temp;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar i = library.length - 1;\r\n\t\t\t\t\t\r\n\t\t\t\t\twhile (i >= 0) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tlibrary[i].stop (properties, complete, sendEvent);\r\n\t\t\t\t\t\ti--;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Creates a tween-based timer, which is useful for synchronizing function calls with other animations\r\n\t * @example\t\t<code>Actuate.timer (1).onComplete (trace, [ \"Timer is now complete\" ]);</code>\r\n\t * @param\tduration\t\tThe length of the timer in seconds\r\n\t * @param\tcustomActuator\t\tA custom actuator to use instead of the default (Optional)\r\n\t * @return\t\tThe current actuator instance, which can be used to apply properties like onComplete or to gain a reference to the target timer object\r\n\t */\r\n\tpublic static function timer (duration:Float, customActuator:Class<GenericActuator<TweenTimer>> = null):GenericActuator<TweenTimer> {\r\n\t\t\r\n\t\treturn cast tween (new TweenTimer (0), duration, new TweenTimer (1), false, cast customActuator);\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t#if (flash || nme || openfl)\r\n\t\r\n\t/**\r\n\t * Creates a new transform tween\r\n\t * @example\t\t<code>Actuate.transform (MyClip, 1).color (0xFF0000);</code>\r\n\t * @param\ttarget\t\tThe object to tween\r\n\t * @param\tduration\t\tThe length of the tween in seconds\r\n\t * @param\toverwrite\t\tSets whether previous tweens for the same target and properties will be overwritten (Default is true)\r\n\t * @return\t\tA TransformOptions instance, which is used to select the kind of transform you would like to apply to the target\r\n\t */\r\n\t/*@:generic*/ public static function transform<T> (target:T, duration:Float = 0, overwrite:Bool = true):TransformOptions<T> {\r\n\t\t\r\n\t\treturn new TransformOptions (target, duration, overwrite);\r\n\t\t\r\n\t}\r\n\t\r\n\t#end\r\n\t\r\n\t\r\n\t/**\r\n\t * Creates a new tween\r\n\t * @example\t\t<code>Actuate.tween (MyClip, 1, { alpha: 1 } ).onComplete (trace, [ \"MyClip is now visible\" ]);</code>\r\n\t * @param\ttarget\t\tThe object to tween\r\n\t * @param\tduration\t\tThe length of the tween in seconds\r\n\t * @param\tproperties\t\tThe end values to tween the target to\r\n\t * @param\toverwrite\t\t\tSets whether previous tweens for the same target and properties will be overwritten (Default is true)\r\n\t * @param\tcustomActuator\t\tA custom actuator to use instead of the default (Optional)\r\n\t * @return\t\tThe current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate\r\n\t */ \r\n\t/*@:generic*/ public static function tween<T> (target:T, duration:Float, properties:Dynamic, overwrite:Bool = true, customActuator:Class<GenericActuator<T>> = null):GenericActuator<T> {\r\n\t\t\r\n\t\tif (target != null) {\r\n\t\t\t\r\n\t\t\tif (duration > 0) {\r\n\t\t\t\t\r\n\t\t\t\tif (customActuator == null) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tcustomActuator = cast defaultActuator;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar actuator:GenericActuator<T> = Type.createInstance (customActuator, [ target, duration, properties ]);\r\n\t\t\t\tvar library = getLibrary (actuator.target);\r\n\t\t\t\t\r\n\t\t\t\tif (overwrite) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar i = library.length - 1;\r\n\t\t\t\t\t\r\n\t\t\t\t\twhile (i >= 0) {\r\n\t\t\t\t\t\tlibrary[i].stop (actuator.properties, false, false);\r\n\t\t\t\t\t\ti--;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tlibrary = getLibrary (actuator.target);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tlibrary.push (actuator);\r\n\t\t\t\tactuator.move ();\r\n\t\t\t\t\r\n\t\t\t\treturn actuator;\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\treturn apply (target, properties, customActuator);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn null;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/*@:generic*/ public static function unload<T> (actuator:GenericActuator<T>):Void {\r\n\t\t\r\n\t\tvar target = actuator.target;\r\n\t\t\r\n\t\t#if neko\r\n\t\t\r\n\t\tif (Reflect.isFunction (target)) {\r\n\t\t\t\r\n\t\t\tif (methodLibraries.exists (target)) {\r\n\t\t\t\t\r\n\t\t\t\tmethodLibraries.get (target).remove (actuator);\r\n\t\t\t\t\r\n\t\t\t\tif (methodLibraries.get (target).length == 0) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tmethodLibraries.remove (target);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t#end\r\n\t\t\r\n\t\tif (targetLibraries.exists (target)) {\r\n\t\t\t\r\n\t\t\ttargetLibraries.get (target).remove (actuator);\r\n\t\t\t\r\n\t\t\tif (targetLibraries.get (target).length == 0) {\r\n\t\t\t\t\r\n\t\t\t\ttargetLibraries.remove (target);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Creates a new tween that updates a method rather than setting the properties of an object\r\n\t * @example\t\t<code>Actuate.update (trace, 1, [\"Value: \", 0], [\"\", 1]).onComplete (trace, [ \"Finished tracing values between 0 and 1\" ]);</code>\r\n\t * @param\ttarget\t\tThe method to update\t\t\r\n\t * @param\tduration\t\tThe length of the tween in seconds\r\n\t * @param\tstart\t\tThe starting parameters of the method call. You may use both numeric and non-numeric values\r\n\t * @param\tend\t\tThe ending parameters of the method call. You may use both numeric and non-numeric values, but the signature should match the start parameters\r\n\t * @param\toverwrite\t\tSets whether previous tweens for the same target and properties will be overwritten (Default is true)\r\n\t * @return\t\tThe current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate\r\n\t */\r\n\t/*@:generic*/ public static function update<T> (target:T, duration:Float, start:Array <Dynamic> = null, end:Array <Dynamic> = null, overwrite:Bool = true):GenericActuator<T> {\r\n\t\t\t\t\r\n\t\tvar properties:Dynamic = { start: start, end: end };\r\n\t\t\r\n\t\treturn tween (target, duration, properties, overwrite, MethodActuator);\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n}\r\n\r\n\r\n#if !haxe3\r\nimport com.eclecticdesignstudio.motion.actuators.FilterActuator;\r\nimport com.eclecticdesignstudio.motion.actuators.GenericActuator;\r\nimport com.eclecticdesignstudio.motion.actuators.TransformActuator;\r\nimport com.eclecticdesignstudio.motion.Actuate;\r\nimport flash.display.DisplayObject;\r\nimport flash.filters.BitmapFilter;\r\n//import flash.filters.ColorMatrixFilter;\r\nimport flash.geom.Matrix;\r\n#end\r\n\r\n\r\n#if (flash || nme || openfl)\r\n\r\nprivate class EffectsOptions {\r\n\r\n\r\n\tprivate var duration:Float;\r\n\tprivate var overwrite:Bool;\r\n\tprivate var target:DisplayObject;\r\n\r\n\r\n\tpublic function new (target:DisplayObject, duration:Float, overwrite:Bool) {\r\n\t\t\r\n\t\tthis.target = target;\r\n\t\tthis.duration = duration;\r\n\t\tthis.overwrite = overwrite;\r\n\t\t\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Creates a new BitmapFilter tween\r\n\t * @param\treference\t\tA reference to the target's filter, which can be an array index or the class of the filter\r\n\t * @param\tproperties\t\tThe end properties to use for the tween\r\n\t * @return\t\tThe current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate\r\n\t */\r\n\tpublic function filter (reference:Dynamic, properties:Dynamic):IGenericActuator {\r\n\t\t\r\n\t\tproperties.filter = reference;\r\n\t\t\r\n\t\treturn Actuate.tween (target, duration, properties, overwrite, FilterActuator);\r\n\t\t\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\nprivate class TransformOptions<T> {\r\n\r\n\r\n\tprivate var duration:Float;\r\n\tprivate var overwrite:Bool;\r\n\tprivate var target:T;\r\n\r\n\r\n\tpublic function new (target:T, duration:Float, overwrite:Bool) {\r\n\t\t\r\n\t\tthis.target = target;\r\n\t\tthis.duration = duration;\r\n\t\tthis.overwrite = overwrite;\r\n\t\t\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Creates a new ColorTransform tween\r\n\t * @param\tcolor\t\tThe color value\r\n\t * @param\tstrength\t\tThe percentage amount of tint to apply (Default is 1)\r\n\t * @param\talpha\t\tThe end alpha of the target. If you wish to tween alpha and tint simultaneously, you must do them both as part of the ColorTransform. A value of null will make no change to the alpha of the object (Default is null)\r\n\t * @return\t\tThe current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate\r\n\t */\r\n\tpublic function color (value:Int = 0x000000, strength:Float = 1, alpha:Null <Float> = null):IGenericActuator {\r\n\t\t\r\n\t\tvar properties:Dynamic = { colorValue: value, colorStrength: strength };\r\n\t\t\r\n\t\tif (alpha != null) {\r\n\t\t\t\r\n\t\t\tproperties.colorAlpha = alpha;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn Actuate.tween (target, duration, properties, overwrite, TransformActuator);\r\n\t\t\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Creates a new SoundTransform tween\r\n\t * @param\tvolume\t\tThe end volume for the target, or null if you would like to ignore this property (Default is null)\r\n\t * @param\tpan\t\tThe end pan for the target, or null if you would like to ignore this property (Default is null)\r\n\t * @return\t\tThe current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate\r\n\t */\r\n\tpublic function sound (volume:Null <Float> = null, pan:Null <Float> = null):IGenericActuator {\r\n\t\t\r\n\t\tvar properties:Dynamic = {};\r\n\t\t\r\n\t\tif (volume != null) {\r\n\t\t\t\r\n\t\t\tproperties.soundVolume = volume;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tif (pan != null) {\r\n\t\t\t\r\n\t\t\tproperties.soundPan = pan;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn Actuate.tween (target, duration, properties, overwrite, TransformActuator);\r\n\t\t\r\n\t}\r\n\r\n\r\n}\r\n\r\n#end\r\n\r\n\r\nprivate class TweenTimer {\r\n\r\n\r\n\tpublic var progress:Float;\r\n\r\n\r\n\tpublic function new (progress:Float):Void {\r\n\t\t\r\n\t\tthis.progress = progress;\r\n\t\t\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n#if neko\r\nprivate class KVPairMap<K, V>  {\r\n\tvar keyList:Array<K>;\r\n\tvar valList:Array<V>;\r\n\tpublic function new() {\r\n\t\tthis.keyList = [];\r\n\t\tthis.valList = [];\r\n\t}\r\n\tfunction equals(k1:K, k2:K):Bool \r\n\t\treturn throw 'base';\r\n\t\r\n\tfunction indexOf(k:K):Int {\r\n\t\tfor (i in 0...keyList.length)\r\n\t\t\tif (equals(k, keyList[i])) return i;\r\n\t\treturn -1;\r\n\t}\r\n\tpublic function get(k:K):Null<V> \r\n\t\treturn valList[indexOf(k)];\r\n\t\r\n\tpublic function set(k:K, v:V):V {\r\n\t\tvar i = indexOf(k);\r\n\t\tif (i == -1) {\r\n\t\t\tkeyList.push(k);\r\n\t\t\tvalList.push(v);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tkeyList[i] = k;\r\n\t\t\tvalList[i] = v;\r\n\t\t}\r\n\t\treturn v;\r\n\t}\r\n\tpublic function exists(k:K):Bool \r\n\t\treturn indexOf(k) != -1;\r\n\t\r\n\tpublic function remove(k:K):Bool {\r\n\t\tvar i = indexOf(k);\r\n\t\treturn\r\n\t\t\tif (i == -1) false;\r\n\t\t\telse {\r\n\t\t\t\tkeyList.splice(i, 1);\r\n\t\t\t\tvalList.splice(i, 1);\r\n\t\t\t\ttrue;\r\n\t\t\t}\r\n\t}\r\n\tpublic inline function keys():Iterator<K> \r\n\t\treturn keyList.iterator();\r\n\t\r\n\tpublic inline function iterator():Iterator<V> \r\n\t\treturn valList.iterator();\r\n\t\r\n\tpublic function toString() {\r\n\t\treturn [for (i in 0...keyList.length) Std.string(keyList[i]) => valList[i]].toString();\r\n\t}\r\n\t\r\n}\r\n\r\n       private class FunctionMap < K, V > extends KVPairMap < K, V > {\r\n                override function equals(k1:K, k2:K):Bool {\r\n                        return Reflect.compareMethods(k1, k2);\r\n                }\r\n        }\r\n\r\n#end","﻿package motion.actuators;\r\n\r\n\r\nclass MethodActuator<T> extends SimpleActuator<T, T> {\r\n\t\r\n\t\r\n\tprivate var currentParameters:Array <Dynamic>;\r\n\tprivate var tweenProperties:Dynamic;\r\n\t\r\n\t\r\n\tpublic function new (target:T, duration:Float, properties:Dynamic) {\r\n\t\t\r\n\t\tcurrentParameters = new Array <Dynamic> ();\r\n\t\ttweenProperties = { };\r\n\t\t\r\n\t\tsuper (target, duration, properties);\r\n\t\t\r\n\t\tif (!Reflect.hasField (properties, \"start\")) {\r\n\t\t\t\r\n\t\t\tthis.properties.start = new Array <Dynamic> ();\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tif (!Reflect.hasField (properties, \"end\")) {\r\n\t\t\t\r\n\t\t\tthis.properties.end = this.properties.start;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tfor (i in 0...this.properties.start.length) {\r\n\t\t\t\r\n\t\t\tcurrentParameters.push (this.properties.start[i]);\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\tprivate override function apply ():Void {\r\n\t\t\r\n\t\tcallMethod (target, properties.end);\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate override function complete (sendEvent:Bool = true):Void {\r\n\t\t\r\n\t\tfor (i in 0...properties.start.length) {\r\n\t\t\t\r\n\t\t\tcurrentParameters[i] = Reflect.field (tweenProperties, \"param\" + i);\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tcallMethod (target, currentParameters);\r\n\t\t\r\n\t\tsuper.complete (sendEvent);\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate override function initialize ():Void {\r\n\t\t\r\n\t\tvar details:PropertyDetails<T>;\r\n\t\tvar propertyName:String;\r\n\t\tvar start:Dynamic;\r\n\t\t\r\n\t\tfor (i in 0...properties.start.length) {\r\n\t\t\t\r\n\t\t\tpropertyName = \"param\" + i;\r\n\t\t\tstart = properties.start[i];\r\n\t\t\t\r\n\t\t\tReflect.setField (tweenProperties, propertyName, start);\r\n\t\t\t\r\n\t\t\tif (Std.is (start, Float) || Std.is (start, Int)) {\r\n\t\t\t\t\r\n\t\t\t\tdetails = new PropertyDetails (tweenProperties, propertyName, start, properties.end[i] - start);\r\n\t\t\t\tpropertyDetails.push (details);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tdetailsLength = propertyDetails.length;\r\n\t\tinitialized = true;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate override function update (currentTime:Float):Void {\r\n\t\t\r\n\t\tsuper.update (currentTime);\r\n\t\t\r\n\t\tif (active && !paused) {\r\n\t\t\t\r\n\t\t\tfor (i in 0...properties.start.length) {\r\n\t\t\t\t\r\n\t\t\t\tcurrentParameters[i] = Reflect.field (tweenProperties, \"param\" + i);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcallMethod (target, currentParameters);\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n}","﻿package motion.actuators;\r\n\r\n\r\nimport motion.MotionPath;\r\n\r\n\r\nclass MotionPathActuator<T> extends SimpleActuator<T, T> {\r\n\t\r\n\t\r\n\tpublic function new (target:T, duration:Float, properties:Dynamic) {\r\n\t\t\r\n\t\tsuper (target, duration, properties);\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate override function apply ():Void {\r\n\t\t\r\n\t\tfor (propertyName in Reflect.fields (properties)) {\r\n\t\t\t\r\n\t\t\t#if (haxe_209 || haxe3)\r\n\t\t\t\r\n\t\t\tif (#if flash false && #end Reflect.hasField (target, propertyName)) {\r\n\t\t\t\t\r\n\t\t\t\tReflect.setField (target, propertyName, cast (Reflect.field (properties, propertyName), IComponentPath).end);\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\tReflect.setProperty (target, propertyName, cast (Reflect.field (properties, propertyName), IComponentPath).end);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t#else\r\n\t\t\t\r\n\t\t\tReflect.setField (target, propertyName, cast (Reflect.field (properties, propertyName), IComponentPath).end);\r\n\t\t\t\r\n\t\t\t#end\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate override function initialize ():Void {\r\n\t\t\r\n\t\tvar details:PropertyPathDetails<T>;\r\n\t\tvar path:IComponentPath;\r\n\t\t\r\n\t\tfor (propertyName in Reflect.fields (properties)) {\r\n\t\t\t\r\n\t\t\tpath = cast (Reflect.field (properties, propertyName), IComponentPath);\r\n\t\t\t\r\n\t\t\tif (path != null) {\r\n\t\t\t\t\r\n\t\t\t\tvar isField = true;\r\n\t\t\t\t\r\n\t\t\t\t#if (haxe_209 || haxe3)\r\n\t\t\t\t\r\n\t\t\t\tif (#if flash false && #end Reflect.hasField (target, propertyName)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tpath.start = Reflect.field (target, propertyName);\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\tisField = false;\r\n\t\t\t\t\tpath.start = Reflect.getProperty (target, propertyName);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t#else\r\n\t\t\t\t\r\n\t\t\t\tpath.start = Reflect.field (target, propertyName);\r\n\t\t\t\t\r\n\t\t\t\t#end\r\n\t\t\t\t\r\n\t\t\t\tdetails = new PropertyPathDetails (target, propertyName, path, isField);\r\n\t\t\t\tpropertyDetails.push (details);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tdetailsLength = propertyDetails.length;\r\n\t\tinitialized = true;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tprivate override function update (currentTime:Float):Void {\r\n\t\t\r\n\t\tif (!paused) {\r\n\t\t\t\r\n\t\t\tvar details:PropertyPathDetails<T>;\r\n\t\t\tvar easing:Float;\r\n\t\t\t\r\n\t\t\tvar tweenPosition = (currentTime - timeOffset) / duration;\r\n\t\t\t\r\n\t\t\tif (tweenPosition > 1) {\r\n\t\t\t\t\r\n\t\t\t\ttweenPosition = 1;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (!initialized) {\r\n\t\t\t\t\r\n\t\t\t\tinitialize ();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (!special) {\r\n\t\t\t\t\r\n\t\t\t\teasing = _ease.calculate (tweenPosition);\r\n\t\t\t\t\r\n\t\t\t\tfor (details in propertyDetails) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (details.isField) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tReflect.setField (details.target, details.propertyName, cast (details, PropertyPathDetails<Dynamic>).path.calculate (easing));\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t#if (haxe_209 || haxe3)\r\n\t\t\t\t\t\tReflect.setProperty (details.target, details.propertyName, cast (details, PropertyPathDetails<Dynamic>).path.calculate (easing));\r\n\t\t\t\t\t\t#end\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\tif (!_reverse) {\r\n\t\t\t\t\t\r\n\t\t\t\t\teasing = _ease.calculate (tweenPosition);\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\teasing = _ease.calculate (1 - tweenPosition);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar endValue:Float;\r\n\t\t\t\t\r\n\t\t\t\tfor (details in propertyDetails) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (!_snapping) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (details.isField) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tReflect.setField (details.target, details.propertyName, cast (details, PropertyPathDetails<Dynamic>).path.calculate (easing));\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t#if (haxe_209 || haxe3)\r\n\t\t\t\t\t\t\tReflect.setProperty (details.target, details.propertyName, cast (details, PropertyPathDetails<Dynamic>).path.calculate (easing));\r\n\t\t\t\t\t\t\t#end\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (details.isField) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tReflect.setField (details.target, details.propertyName, Math.round (cast (details, PropertyPathDetails<Dynamic>).path.calculate (easing)));\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t#if (haxe_209 || haxe3)\r\n\t\t\t\t\t\t\tReflect.setProperty (details.target, details.propertyName, Math.round (cast (details, PropertyPathDetails<Dynamic>).path.calculate (easing)));\r\n\t\t\t\t\t\t\t#end\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (tweenPosition == 1) {\r\n\t\t\t\t\r\n\t\t\t\tif (_repeat == 0) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tactive = false;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (toggleVisible && getField (target, \"alpha\") == 0) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tsetField (target, \"visible\", false);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tcomplete (true);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (_onRepeat != null) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcallMethod (_onRepeat, _onRepeatParams);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (_reflect) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t_reverse = !_reverse;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tstartTime = currentTime;\r\n\t\t\t\t\ttimeOffset = startTime + _delay;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (_repeat > 0) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t_repeat --;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (sendChange) {\r\n\t\t\t\t\r\n\t\t\t\tchange ();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n}\r\n\r\n\r\n#if !haxe3\r\nimport com.eclecticdesignstudio.motion.MotionPath;\r\n#end\r\n\r\n\r\nclass PropertyPathDetails<T> extends PropertyDetails<T> {\r\n\t\r\n\t\r\n\tpublic var path:IComponentPath;\r\n\t\r\n\t\r\n\tpublic function new (target:T, propertyName:String, path:IComponentPath, isField:Bool = true) {\r\n\t\t\r\n\t\tsuper (target, propertyName, 0, 0, isField);\r\n\t\t\r\n\t\tthis.path = path;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n}","﻿package motion.actuators;\r\n\r\n\r\nclass PropertyDetails<T> {\r\n\t\r\n\t\r\n\tpublic var change:Float;\r\n\tpublic var isField:Bool;\r\n\tpublic var propertyName:String;\r\n\tpublic var start:Float;\r\n\tpublic var target:T;\r\n\t\r\n\t\r\n\tpublic function new (target:T, propertyName:String, start:Float, change:Float, isField:Bool = true):Void {\r\n\t\t\r\n\t\tthis.target = target;\r\n\t\tthis.propertyName = propertyName;\r\n\t\tthis.start = start;\r\n\t\tthis.change = change;\r\n\t\tthis.isField = isField;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n}","package samples.basics;\n\nimport motion.Actuate;\nimport pixi.core.graphics.Graphics;\nimport pixi.core.display.Container;\nimport pixi.core.textures.Texture;\nimport pixi.core.renderers.SystemRenderer;\nimport pixi.core.renderers.Detector;\nimport pixi.core.sprites.Sprite;\nimport js.Browser;\n\nclass Main {\n\n\tvar _bunny:Sprite;\n\tvar _renderer:SystemRenderer;\n\tvar _container:Container;\n\n\tvar _graphic:Graphics;\n\n\tpublic function new() {\n\t\t// Rendering options usage sample\n\t\tvar options:RenderingOptions = {};\n\t\toptions.backgroundColor = 0x006666;\n\t\toptions.resolution = 1;\n\t\toptions.transparent = true;\n\t\toptions.antialias = true;\n\n\t\t_container = new Container();\n\t\t_renderer = Detector.autoDetectRenderer(800, 600, options);\n\n\t\t_bunny = new Sprite(Texture.fromImage(\"assets/basics/bunny.png\"));\n\t\t_bunny.anchor.set(0.5);\n\t\t_bunny.position.set(400, 300);\n\n\t\t_container.addChild(_bunny);\n\n\n\t\tActuate.tween(_bunny.scale, 10, {  x : 10, y : 10 });\n\n\t\t_graphic = new Graphics();\n\t\t_graphic.beginFill(0xFF0000, 0.4);\n\t\t_graphic.drawRect(200, 150, 400, 300);\n\t\t_graphic.endFill();\n\n\t\t_graphic.interactive = true;\n\t\t_graphic.on(\"click\", function(evt) {trace(evt);});\n\n\t\t_container.addChild(_graphic);\n\n\t\tBrowser.document.body.appendChild(_renderer.view);\n\t\tBrowser.window.requestAnimationFrame(cast _animate);\n\t}\n\n\tfunction _animate() {\n\t\tBrowser.window.requestAnimationFrame(cast _animate);\n\t\t_bunny.rotation += 0.1;\n\t\t_renderer.render(_container);\n\t}\n\n\tstatic function main() {\n\t\tnew Main();\n\t}\n}"],
"names":[],
"mappings":"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"
}